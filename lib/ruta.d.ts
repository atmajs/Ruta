// Generated by dts-bundle v0.7.3

declare module 'ruta' {
    import Ruta from 'ruta/ruta';
    export = Ruta;
}

declare module 'ruta/ruta' {
    import { query_deserialize } from 'ruta/utils/query'; 
     import { query_serialize } from 'ruta/utils/query'; 
     import { path_fromCLI } from 'ruta/utils/path'; 
     import RouteCollection from 'ruta/route/RouteCollection';
    
    import { ILifeCycleEvent } from 'ruta/emit/Lifycycle';
    import { LocationNavigateOptions, LocationBackOptions } from 'ruta/emit/ILocationSource';
    import { Route } from 'ruta/route/Route';
    import { IState } from 'ruta/emit/Stack';
    export { IState as State };
    const _default: {
            Collection: typeof RouteCollection;
            Route: typeof Route;
            setRouterType(type: 'hash' | 'history' | 'memory'): any;
            setStrictBehaviour(isStrict: boolean): any;
            add(regpath: any, mix: any): any;
            on(regpath: any, mix: any): any;
            off(regpath: any, mix: any): any;
            onLifecycle(def: string, cb: (event: ILifeCycleEvent) => void): any;
            offLifecycle(def: string, cb: any): any;
            get(path: string): Route;
            navigate(mix: any, opts?: LocationNavigateOptions): any;
            back(opts?: LocationBackOptions): void;
            forward(): void;
            current(): Route;
            currentPath(): string;
            getStack(): IState[];
            getBackStack(): IState[];
            getForwardStack(): IState[];
            notifyCurrent(): any;
            parse: typeof RouteCollection.parse;
            $utils: {
                    pathFromCLI: typeof path_fromCLI;
                    query: {
                            serialize: typeof query_serialize;
                            deserialize: typeof query_deserialize;
                            get: (path_: any) => {
                                    [key: string]: string;
                            };
                    };
            };
            _: {
                    pathFromCLI: typeof path_fromCLI;
                    query: {
                            serialize: typeof query_serialize;
                            deserialize: typeof query_deserialize;
                            get: (path_: any) => {
                                    [key: string]: string;
                            };
                    };
            };
    };
    export default _default;
}

declare module 'ruta/utils/query' {
    export function query_deserialize(query: string, delimiter?: string): {};
    export function query_serialize(params: any, delimiter: any): string;
}

declare module 'ruta/utils/path' {
    export function path_normalize(str: string): string;
    export function path_split(path: string): string[];
    export function path_join(pathParts: string[]): string;
    export function path_fromCLI(commands: any): string;
    export function path_getQuery(path: string): {
        [key: string]: string;
    };
    export function path_setQuery(path: string, mix: string | object): string;
}

declare module 'ruta/route/RouteCollection' {
    import { Route } from 'ruta/route/Route';
    export default class RouteCollection {
        routes: Route[];
        /** alias for `push` */
        add(def: string, value: any): this;
        push(def: string, value: any): this;
        unshift(def: string, value: any): this;
        remove(def: string, value: any): void;
        get(path: string, method?: string): Route;
        getAll(path: string, method?: string): any[];
        clear(): this;
        static parse(definition: string, path: string): {
            path: string;
            params: {};
        };
    }
}

declare module 'ruta/emit/Lifycycle' {
    import LocationEmitter from 'ruta/emit/LocationEmitter';
    import { Route } from 'ruta/route/Route';
    import { LocationNavigateOptions } from 'ruta/emit/ILocationSource';
    export default class Lifecycle {
        location: LocationEmitter;
        definition: string;
        callback: (ILifeCycleEvent: any) => void;
        route: Route;
        state: ILifeCycleEvent;
        constructor(location: LocationEmitter, definition: string, callback: (ILifeCycleEvent: any) => void);
        changed(route: Route, opts: LocationNavigateOptions): void;
        dispose(): void;
    }
    export enum EventType {
        Initial = "initial",
        Enter = "enter",
        Leave = "leave",
        Change = "change"
    }
    export enum Direction {
        Forward = "forward",
        Back = "back"
    }
    export interface ILifeCycleEvent {
        type: EventType;
        direction: Direction;
        route: Route;
    }
}

declare module 'ruta/emit/ILocationSource' {
    export class LocationNavigateOptions {
            /**
                * History step. 1: Forward, 0: Replace Current, -1-(-n): Back
                * @default: 1
                * */
            step?: number;
            /**
                * Backcompat.
                * @deprecated Use `step:0`
                */
            replace?: boolean;
            /** When true and query arguments are used, than navigation extends current query */
            extend?: boolean;
            /** When false listeners are not notified */
            silent?: boolean;
            /** Additional arguments which will be attached to the routes model params */
            params?: any;
            /** If true, navigate will perform back action to the route when in history */
            preferHistory?: boolean;
    }
    export class LocationBackOptions {
            default?: {
                    url: string;
                    opts?: LocationNavigateOptions;
            };
    }
    export interface ILocationSource {
            navigate(path: object | string, opts?: LocationNavigateOptions): any;
            back(): any;
            forward(): any;
            current(): string;
    }
}

declare module 'ruta/route/Route' {
    export interface IRoutePathSegment {
        matcher: {
            test(str: string): boolean;
        };
        alias?: string;
        optional?: boolean;
        isLookAhead?: boolean;
    }
    export class Route {
        definition?: string;
        value: any;
        method: string;
        strict: boolean;
        current: {
            value?: any;
            path: string;
            params: {
                [key: string]: any;
            };
        };
        query: {
            [key: string]: string | RegExp;
        };
        path: (string | IRoutePathSegment)[];
        match?: RegExp;
        constructor(definition?: string, value?: any);
    }
}

declare module 'ruta/emit/Stack' {
    export namespace Stack {
        const stack: IState[];
        const forwardStates: IState[];
        function create(url: string): IState;
        function push(current: IState): void;
        function replace(current: IState): void;
        function goBackById(id: string): number;
        function goBackByCount(count: number): void;
        function goForwardById(id: string): number;
        function goForwardByCount(count: number): void;
        function hasBack(): boolean;
        function hasForwad(): boolean;
        function getCurrent(): IState;
        function getBackStack(): IState[];
        function findInBack(url: string): IState;
    }
    export interface IState {
        id: string;
        url: string;
        [key: string]: any;
    }
}

declare module 'ruta/emit/LocationEmitter' {
    import RouteCollection from 'ruta/route/RouteCollection';
    import { ILocationSource, LocationNavigateOptions, LocationBackOptions } from 'ruta/emit/ILocationSource';
    import Lifecycle, { ILifeCycleEvent } from 'ruta/emit/Lifycycle';
    import { IState } from 'ruta/emit/Stack';
    import { Route } from 'ruta/route/Route';
    export default class LocationEmitter {
        collection: RouteCollection;
        type: 'hash' | 'history' | 'memory';
        listeners: RouteCollection;
        lifecycles: Lifecycle[];
        emitter: ILocationSource;
        constructor(collection?: RouteCollection, type?: 'hash' | 'history' | 'memory');
        /** Is also called by the emitter */
        onChanged(path: any, opts?: LocationNavigateOptions): void;
        navigate(mix?: any, opts?: LocationNavigateOptions): void;
        back(opts?: LocationBackOptions): void;
        forward(): void;
        getStack(): IState[];
        getBackStack(): IState[];
        getForwardStack(): IState[];
        current(): Route;
        currentPath(): string;
        on(def: any, cb: (route: Route, opts?: LocationNavigateOptions) => void): void;
        off(def: any, cb?: Function): void;
        onLifecycle(def: any, cb: (event: ILifeCycleEvent) => void): void;
        offLifecycle(def: any, cb?: Function): void;
    }
}

